var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// tnrtodo: figure out where to insert this validation exactly..
var bsonObjectid = require("bson-objectid");
var getAminoAcidDataForEachBaseOfDna = require("./getAminoAcidDataForEachBaseOfDna");

var _require = require("lodash"),
    cloneDeep = _require.cloneDeep;

var annotationTypes = require("./annotationTypes");
var filterSequenceString = require("./filterSequenceString");
var tidyUpAnnotation = require("./tidyUpAnnotation");
var filterAminoAcidSequenceString = require("./filterAminoAcidSequenceString");
var getDegenerateDnaStringFromAaString = require("./getDegenerateDnaStringFromAAString");

module.exports = function tidyUpSequenceData(pSeqData) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var annotationsAsObjects = options.annotationsAsObjects,
      logMessages = options.logMessages,
      removeUnwantedChars = options.removeUnwantedChars,
      additionalValidChars = options.additionalValidChars,
      noTranslationData = options.noTranslationData,
      charOverrides = options.charOverrides,
      doNotProvideIdsForAnnotations = options.doNotProvideIdsForAnnotations,
      proteinFilterOptions = options.proteinFilterOptions,
      convertAnnotationsFromAAIndices = options.convertAnnotationsFromAAIndices;

  var seqData = cloneDeep(pSeqData); //sequence is usually immutable, so we clone it and return it
  var response = {
    messages: []
  };
  if (!seqData) {
    seqData = {};
  }
  if (!seqData.sequence) {
    seqData.sequence = "";
  }
  if (!seqData.proteinSequence) {
    seqData.proteinSequence = "";
  }
  var needsBackTranslation = false;
  if (seqData.isProtein) {
    seqData.circular = false; //there are no circular proteins..
    if (!seqData.proteinSequence && seqData.proteinSequence !== "") {
      seqData.proteinSequence = seqData.sequence; //if there is no proteinSequence, assign seqData.sequence
    }
    if (!seqData.sequence || seqData.sequence.length !== seqData.proteinSequence.length * 3) {
      //if we don't have a sequence or it is clear that the DNA sequence doesn't match the proteinSequence, add a back translation
      needsBackTranslation = true;
    }
  }
  if (seqData.isRna) {
    //flip all t's to u's
    seqData.sequence = seqData.sequence.replace(/t/gi, "u");
  }
  if (removeUnwantedChars) {
    if (seqData.isProtein) {
      seqData.proteinSequence = filterAminoAcidSequenceString(seqData.proteinSequence, _extends({ includeStopCodon: true }, proteinFilterOptions));
    } else {
      seqData.sequence = filterSequenceString(seqData.sequence, "" + (additionalValidChars || "") + (seqData.isRna || seqData.isMixedRnaAndDna ? "u" : "" //if it is rna or mixed, allow u's
      ), charOverrides);
    }
  }
  if (seqData.isProtein) {
    if (needsBackTranslation) {
      //backtranslate the AA sequence
      seqData.sequence = getDegenerateDnaStringFromAaString(seqData.proteinSequence);
    }
    seqData.aminoAcidDataForEachBaseOfDNA = getAminoAcidDataForEachBaseOfDna(seqData.proteinSequence, true, null, true);
  }

  seqData.size = seqData.noSequence ? seqData.size : seqData.sequence.length;
  seqData.proteinSize = seqData.noSequence ? seqData.proteinSize : seqData.proteinSequence.length;
  if (seqData.circular === "false" ||
  /* eslint-disable eqeqeq*/

  seqData.circular == -1 ||
  /* eslint-enable eqeqeq*/

  !seqData.circular) {
    seqData.circular = false;
  } else {
    seqData.circular = true;
  }

  annotationTypes.forEach(function (annotationType) {
    if (!Array.isArray(seqData[annotationType])) {
      if (_typeof(seqData[annotationType]) === "object") {
        seqData[annotationType] = Object.keys(seqData[annotationType]).map(function (key) {
          return seqData[annotationType][key];
        });
      } else {
        seqData[annotationType] = [];
      }
    }
    seqData[annotationType] = seqData[annotationType].filter(function (annotation) {
      return tidyUpAnnotation(annotation, _extends({}, options, {
        sequenceData: seqData,
        convertAnnotationsFromAAIndices: convertAnnotationsFromAAIndices,
        mutative: true,
        annotationType: annotationType
      }));
    });
  });

  if (!noTranslationData) {
    seqData.translations = seqData.translations.map(function (translation) {
      if (!translation.aminoAcids && !seqData.noSequence) {
        translation.aminoAcids = getAminoAcidDataForEachBaseOfDna(seqData.sequence, translation.forward, translation);
      }
      return translation;
    });
  }

  if (annotationsAsObjects) {
    annotationTypes.forEach(function (name) {
      seqData[name] = seqData[name].reduce(function (acc, item) {
        var itemId = void 0;
        if (item.id || item.id === 0) {
          itemId = item.id;
        } else {
          itemId = bsonObjectid().str;
          if (!doNotProvideIdsForAnnotations) {
            item.id = itemId; //assign the newly created id to the item
          }
        }
        acc[itemId] = item;
        return acc;
      }, {});
    });
  }
  if (logMessages && response.messages.length > 0) {
    console.info("tidyUpSequenceData messages:", response.messages);
  }
  return seqData;
};