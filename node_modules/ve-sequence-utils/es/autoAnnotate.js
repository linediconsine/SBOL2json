var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/* Copyright (C) 2018 TeselaGen Biotechnology, Inc. */
var _require = require("lodash"),
    forEach = _require.forEach,
    omitBy = _require.omitBy;

var bioData = require("./bioData");

var _require2 = require("ve-range-utils"),
    normalizePositionByRangeLength = _require2.normalizePositionByRangeLength,
    reversePositionInRange = _require2.reversePositionInRange;

var getReverseComplementSequenceString = require("./getReverseComplementSequenceString");

var ambiguous_dna_values = bioData.ambiguous_dna_values;
//seqsToAnnotateById must not be length = 0

function autoAnnotate(_ref) {
  var seqsToAnnotateById = _ref.seqsToAnnotateById,
      annotationsToCheckById = _ref.annotationsToCheckById,
      compareName = _ref.compareName,
      warnIfMoreThan = _ref.warnIfMoreThan;

  var annotationsToAddBySeqId = {};

  forEach(annotationsToCheckById, function (ann) {
    var reg = new RegExp(ann.sequence, "gi");
    forEach(omitBy(seqsToAnnotateById, function (s) {
      return !s.sequence.length;
    }), function (_ref2, id) {
      var circular = _ref2.circular,
          sequence = _ref2.sequence;

      function getMatches(_ref3) {
        var seqToMatchAgainst = _ref3.seqToMatchAgainst,
            isReverse = _ref3.isReverse,
            seqLen = _ref3.seqLen;

        var match = void 0;
        var lastMatch = void 0;
        // const matches = []
        try {
          while (match = reg.exec(seqToMatchAgainst)) {
            var _match = match,
                matchStart = _match.index,
                matchSeq = _match[0];

            if (matchStart >= seqLen) return;
            var matchEnd = matchStart + matchSeq.length;
            if (lastMatch) {
              if (matchStart > lastMatch.start && matchEnd <= lastMatch.end) {
                reg.lastIndex = match.index + 1;
                continue;
              }
            }
            lastMatch = {
              start: matchStart,
              end: matchEnd
            };
            var range = {
              start: matchStart,
              end: normalizePositionByRangeLength(matchEnd - 1, seqLen)
            };
            if (!annotationsToAddBySeqId[id]) annotationsToAddBySeqId[id] = [];
            annotationsToAddBySeqId[id].push(_extends({}, isReverse ? {
              start: reversePositionInRange(range.end, seqLen),
              end: reversePositionInRange(range.start, seqLen)
            } : range, {
              strand: isReverse ? -1 : 1,
              id: ann.id
            }));

            reg.lastIndex = match.index + 1;
          }
        } catch (error) {
          console.error("error:", error);
        }
      }
      var seqLen = sequence.length;

      var revSeq = getReverseComplementSequenceString(sequence);
      getMatches({
        seqLen: seqLen,
        seqToMatchAgainst: circular ? sequence + sequence : sequence
      });
      getMatches({
        seqLen: seqLen,
        isReverse: true,
        seqToMatchAgainst: circular ? revSeq + revSeq : revSeq
      });
    });
  });

  //loop through all patterns and get all matches

  var toReturn = {};

  forEach(annotationsToAddBySeqId, function (anns, id) {
    var origSeq = seqsToAnnotateById[id];
    var alreadyExistingAnnsByStartEnd = {};
    forEach(origSeq.annotations, function (ann) {
      alreadyExistingAnnsByStartEnd[getStartEndStr(ann, { compareName: compareName })] = ann;
    });
    var warningCounter = {};
    var toAdd = anns.filter(function (ann) {
      var alreadyExistingAnn = alreadyExistingAnnsByStartEnd[getStartEndStr(ann, { compareName: compareName })];
      if (alreadyExistingAnn) return false;
      if (warnIfMoreThan) {
        warningCounter[ann.id] = (warningCounter[ann.id] || 0) + 1;
      }
      return true;
    }).sort(function (a, b) {
      return a.start - b.start;
    });
    if (toAdd.length) {
      toReturn[id] = toAdd;
    }
    warnIfMoreThan && forEach(warningCounter, function (num, annId) {
      if (num > warnIfMoreThan) {
        toReturn.__more_than_warnings = toReturn.__more_than_warnings || {};
        toReturn.__more_than_warnings[id] = toReturn.__more_than_warnings[id] || [];
        toReturn.__more_than_warnings[id].push(annId);
      }
    });
  });
  return toReturn;
}

function getStartEndStr(_ref4, _ref5) {
  var start = _ref4.start,
      end = _ref4.end,
      name = _ref4.name,
      strand = _ref4.strand,
      forward = _ref4.forward;
  var compareName = _ref5.compareName;

  var isReverse = strand === -1 || forward === false;
  return start + "-" + end + "-" + (isReverse ? "rev" : "for") + "-" + (compareName ? name : "");
}

function convertApELikeRegexToRegex() {
  var regString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

  var newstr = "";
  var rightOfCaretHolder = "";
  var afterRightCaretHolder = "";
  var beforeRightCaret = "";
  var prevBp = void 0;
  var hitLeftCaret = void 0;
  var hitRightCaret = void 0;

  // eslint-disable-next-line no-unused-vars
  for (var _iterator = regString.replace("(", "").replace(")", ""), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    /* eslint-disable no-loop-func*/
    /* eslint-disable no-inner-declarations*/
    var maybeHandleRightCaret = function maybeHandleRightCaret(justAdded) {
      if (hitRightCaret) {
        rightOfCaretHolder += justAdded;
        afterRightCaretHolder = "" + rightOfCaretHolder + (afterRightCaretHolder.length ? "|" : "") + afterRightCaretHolder;
      }
    };
    /* eslint-enable no-loop-func*/
    /* eslint-enable no-inner-declarations*/


    var _ref6;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref6 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref6 = _i.value;
    }

    var bp = _ref6;
    var ambigVal = ambiguous_dna_values[bp.toUpperCase()];
    if (ambigVal && ambigVal.length > 1) {
      var valToUse = void 0;
      if (ambigVal.length === 4) {
        valToUse = ".";
      } else {
        valToUse = "[" + ambigVal + "]";
      }
      newstr += valToUse;
      maybeHandleRightCaret(valToUse);
      continue;
    }
    if (bp === "#") {
      if (hitRightCaret) throw new Error("Error converting regex");
      var _valToUse = prevBp ? "[^" + prevBp + "]*?" : ".*?";
      newstr += _valToUse;
      maybeHandleRightCaret(_valToUse);
      continue;
    }
    if (bp === "<") {
      var _ret = function () {
        if (hitRightCaret) throw new Error("Error converting to regex");
        if (hitLeftCaret) throw new Error("Error converting to regex");
        var holder = "";
        var stringToAdd = "";
        var isGroupClosed = true;
        var closingBraceHit = void 0;
        var groups = [];
        for (var index = 0; index < newstr.length; index++) {
          var char = newstr[index];
          var nextChar = newstr[index + 1];
          if (char === "[") {
            isGroupClosed = false;
          } else if (char === "]" || closingBraceHit) {
            closingBraceHit = true;
            if (ambiguous_dna_values[nextChar] || nextChar === "[") {
              isGroupClosed = true;
              closingBraceHit = false;
            }
          }
          holder += char;
          if (isGroupClosed) {
            groups.push(holder);
            holder = "";
          }
        }
        var concattedEls = "";
        groups.reverse();
        groups.forEach(function (g) {
          concattedEls = g + concattedEls;
          stringToAdd = "" + concattedEls + (stringToAdd.length ? "|" : "") + stringToAdd;
        });
        newstr = "(" + stringToAdd + ")?";
        hitLeftCaret = true;
        return "continue";
      }();

      if (_ret === "continue") continue;
    }
    if (bp === ">") {
      if (hitRightCaret) throw new Error("Error converting regex");
      hitRightCaret = true;
      beforeRightCaret = newstr;
      continue;
    }
    newstr += bp;
    maybeHandleRightCaret(bp);
    prevBp = bp;
  }
  if (hitRightCaret) {
    newstr = beforeRightCaret + "(" + afterRightCaretHolder + ")?";
  }
  return newstr;
}

module.exports = {
  convertApELikeRegexToRegex: convertApELikeRegexToRegex,
  autoAnnotate: autoAnnotate
};