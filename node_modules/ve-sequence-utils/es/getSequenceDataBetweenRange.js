var _require = require("lodash"),
    flatMap = _require.flatMap,
    extend = _require.extend,
    forEach = _require.forEach;

var _require2 = require("ve-range-utils"),
    getRangeLength = _require2.getRangeLength;

var convertDnaCaretPositionOrRangeToAa = require("./convertDnaCaretPositionOrRangeToAA");
var insertSequenceDataAtPosition = require("./insertSequenceDataAtPosition");

var _require3 = require("ve-range-utils"),
    getSequenceWithinRange = _require3.getSequenceWithinRange,
    getZeroedRangeOverlaps = _require3.getZeroedRangeOverlaps;

var tidyUpSequenceData = require("./tidyUpSequenceData");
var annotationTypes = require("./annotationTypes");

module.exports = function getSequenceDataBetweenRange(seqData, range) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!range) return seqData;
  var _options$exclude = options.exclude,
      exclude = _options$exclude === undefined ? {} : _options$exclude,
      _options$excludeParti = options.excludePartial,
      excludePartial = _options$excludeParti === undefined ? {} : _options$excludeParti;

  var seqDataToUse = tidyUpSequenceData(seqData);
  var seqDataToReturn = extend({}, seqDataToUse, {
    circular: seqDataToUse.sequence.length === getRangeLength(range, seqData.sequence.length) ? seqDataToUse.circular : false,
    sequence: getSequenceWithinRange(range, seqDataToUse.sequence),
    proteinSequence: getSequenceWithinRange(convertDnaCaretPositionOrRangeToAa(range), seqDataToUse.proteinSequence)
  }, annotationTypes.reduce(function (acc, type) {
    if (exclude[type]) {
      acc[type] = [];
      return acc; //return early cause we're not interested in these annotations
    }
    acc[type] = getAnnotationsBetweenRange(seqDataToUse[type], range, seqDataToUse.sequence.length, excludePartial[type]);
    return acc;
  }, {}));
  if (range.overlapsSelf) {
    var extendedSeqData = insertSequenceDataAtPosition({ sequence: seqDataToReturn.sequence }, seqDataToUse, range.start);

    var toRet = getSequenceDataBetweenRange(extendedSeqData, {
      start: range.end + 1,
      end: range.end
    }, options);
    annotationTypes.forEach(function (type) {
      //we need to go through and adjust any anns where overlapsSelf=true to no longer overlap themselves if they match the range completely
      forEach(toRet[type], function (ann) {
        if (ann.overlapsSelf && ann.start === 0 && getRangeLength(ann, seqDataToUse.sequence.length) === getRangeLength(range, seqDataToUse.sequence.length)) {
          ann.overlapsSelf = false;
          ann.end = toRet.sequence.length - 1;
        }
      });
    });
    return tidyUpSequenceData(toRet);
  }
  return tidyUpSequenceData(seqDataToReturn);
};

function getAnnotationsBetweenRange(annotationsToBeAdjusted, range, maxLength, shouldExcludePartial) {
  return flatMap(annotationsToBeAdjusted, function (annotation) {
    if (annotation.locations && annotation.locations.length) {
      annotation.locations = getAnnotationsBetweenRange(annotation.locations, range, maxLength, shouldExcludePartial);
    }
    //map through every annotation and get the overlap of the annotation with the range
    var overlaps = getZeroedRangeOverlaps(annotation, range, maxLength).map(function (overlap) {
      //we get back 1 or more overlaps here

      return extend({}, annotation, overlap);
    });
    if (shouldExcludePartial) {
      if (overlaps.length > 1) return []; //the annotation has multiple overlaps and thus must be a partial copy so we exclude it completely
      if (overlaps[0]) {
        //there is just 1 overlap, if it doesn't have the same length, it must be a partial copy so we need to exclude it
        if (getRangeLength(overlaps[0], maxLength) !== getRangeLength(annotation, maxLength)) {
          return [];
        }
      }
    }
    return overlaps;
  }); //filter any fully deleted ranges
}