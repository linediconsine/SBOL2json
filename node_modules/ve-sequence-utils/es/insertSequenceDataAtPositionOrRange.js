var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require("ve-range-utils"),
    getRangeLength = _require.getRangeLength;

var _require2 = require("lodash"),
    map = _require2.map,
    cloneDeep = _require2.cloneDeep;

var convertDnaCaretPositionOrRangeToAa = require("./convertDnaCaretPositionOrRangeToAA");
var rotateSequenceDataToPosition = require("./rotateSequenceDataToPosition");

var _require3 = require("ve-range-utils"),
    adjustRangeToInsert = _require3.adjustRangeToInsert,
    adjustRangeToDeletionOfAnotherRange = _require3.adjustRangeToDeletionOfAnotherRange;

var tidyUpSequenceData = require("./tidyUpSequenceData");
var modifiableTypes = require("./annotationTypes").modifiableTypes;
var adjustBpsToReplaceOrInsert = require("./adjustBpsToReplaceOrInsert");

module.exports = function insertSequenceDataAtPositionOrRange(_sequenceDataToInsert, _existingSequenceData, caretPositionOrRange) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  //maintainOriginSplit means that if you're inserting around the origin with n bps selected before the origin
  //when inserting new seq, n bps of the new seq should go in before the origin and the rest should be
  //inserted at the sequence start
  var maintainOriginSplit = options.maintainOriginSplit;

  var existingSequenceData = tidyUpSequenceData(_existingSequenceData);
  var sequenceDataToInsert = tidyUpSequenceData(_sequenceDataToInsert);
  var newSequenceData = cloneDeep(existingSequenceData);
  var insertLength = sequenceDataToInsert.proteinSequence ? sequenceDataToInsert.proteinSequence.length * 3 : sequenceDataToInsert.sequence.length;
  var caretPosition = caretPositionOrRange;

  var isInsertSameLengthAsSelection = sequenceDataToInsert.sequence.length === getRangeLength(caretPositionOrRange, existingSequenceData.sequence.length);

  if (caretPositionOrRange.start > -1 && getRangeLength(caretPositionOrRange, existingSequenceData.sequence.length) === existingSequenceData.sequence.length) {
    //handle the case where we're deleting everything!
    existingSequenceData = tidyUpSequenceData(_extends({}, existingSequenceData, modifiableTypes.reduce(function (acc, type) {
      return acc[type] = [];
    }, {}), {
      sequence: "",
      proteinSequence: "",
      chromatogramData: undefined
    }));
    newSequenceData.chromatogramData = undefined;
  } else if (newSequenceData.chromatogramData && newSequenceData.chromatogramData.baseTraces) {
    //handle chromatogramData updates
    if (caretPositionOrRange && caretPositionOrRange.start > -1) {
      if (caretPositionOrRange.start > caretPositionOrRange.end) {
        newSequenceData.chromatogramData = trimChromatogram({
          chromatogramData: newSequenceData.chromatogramData,
          range: {
            start: caretPositionOrRange.start,
            end: newSequenceData.sequence.length
          },
          justBaseCalls: isInsertSameLengthAsSelection
        });
        newSequenceData.chromatogramData = trimChromatogram({
          chromatogramData: newSequenceData.chromatogramData,
          range: {
            start: 0,
            end: caretPositionOrRange.end
          },
          justBaseCalls: isInsertSameLengthAsSelection
        });
      } else {
        newSequenceData.chromatogramData = trimChromatogram({
          chromatogramData: newSequenceData.chromatogramData,
          range: {
            start: caretPositionOrRange.start,
            end: caretPositionOrRange.end
          },
          justBaseCalls: isInsertSameLengthAsSelection
        });
      }
    }
    if (sequenceDataToInsert.sequence) {
      insertIntoChromatogram({
        chromatogramData: newSequenceData.chromatogramData,
        caretPosition: caretPositionOrRange.start > -1 ? caretPositionOrRange.start : caretPositionOrRange,
        seqToInsert: sequenceDataToInsert.sequence,
        justBaseCalls: isInsertSameLengthAsSelection
      });
    }
  }

  //update the sequence
  newSequenceData.sequence = adjustBpsToReplaceOrInsert(existingSequenceData.sequence, sequenceDataToInsert.sequence, caretPositionOrRange);
  newSequenceData.size = newSequenceData.sequence.length;
  newSequenceData.proteinSequence = adjustBpsToReplaceOrInsert(existingSequenceData.proteinSequence, sequenceDataToInsert.proteinSequence, convertDnaCaretPositionOrRangeToAa(caretPositionOrRange));
  newSequenceData.proteinSize = newSequenceData.proteinSequence.length;

  //handle the insert
  modifiableTypes.forEach(function (annotationType) {
    var existingAnnotations = existingSequenceData[annotationType];
    //update the annotations:
    //handle the delete if necessary
    if (caretPositionOrRange && caretPositionOrRange.start > -1) {
      //we have a range! so let's delete it!
      var range = caretPositionOrRange;
      caretPosition = range.start > range.end ? 0 : range.start;
      //update all annotations for the deletion
      existingAnnotations = adjustAnnotationsToDelete(existingAnnotations, range, existingSequenceData.sequence.length);
    }
    //first clear the newSequenceData's annotations
    newSequenceData[annotationType] = [];
    //in two steps adjust the annotations to the insert
    newSequenceData[annotationType] = newSequenceData[annotationType].concat(adjustAnnotationsToInsert(existingAnnotations, caretPosition, insertLength));
    newSequenceData[annotationType] = newSequenceData[annotationType].concat(adjustAnnotationsToInsert(sequenceDataToInsert[annotationType], 0, caretPosition));
  });
  if (maintainOriginSplit && caretPositionOrRange && caretPositionOrRange.start > caretPositionOrRange.end) {
    //we're replacing around the origin and maintainOriginSplit=true
    //so rotate the resulting seqData n bps
    var caretPosToRotateTo = existingSequenceData.sequence.length - caretPositionOrRange.start;
    return rotateSequenceDataToPosition(newSequenceData, Math.min(caretPosToRotateTo, insertLength));
  }
  return newSequenceData;
};

function adjustAnnotationsToInsert(annotationsToBeAdjusted, insertStart, insertLength) {
  return map(annotationsToBeAdjusted, function (annotation) {
    return _extends({}, adjustRangeToInsert(annotation, insertStart, insertLength), annotation.locations && {
      locations: annotation.locations.map(function (loc) {
        return adjustRangeToInsert(loc, insertStart, insertLength);
      })
    });
  });
}
function adjustAnnotationsToDelete(annotationsToBeAdjusted, range, maxLength) {
  return map(annotationsToBeAdjusted, function (annotation) {
    var newRange = adjustRangeToDeletionOfAnotherRange(annotation, range, maxLength);
    var newLocations = annotation.locations && annotation.locations.map(function (loc) {
      return adjustRangeToDeletionOfAnotherRange(loc, range, maxLength);
    }).filter(function (range) {
      return !!range;
    });
    if (newLocations && newLocations.length) {
      return _extends({}, newRange, {
        start: newLocations[0].start,
        end: newLocations[newLocations.length - 1].end
      }, newLocations.length > 1 && { locations: newLocations });
    } else {
      return newRange;
    }
  }).filter(function (range) {
    return !!range;
  }); //filter any fully deleted ranges
}

function insertIntoChromatogram(_ref) {
  var _chromatogramData$bas, _chromatogramData$bas2, _chromatogramData$qua;

  var chromatogramData = _ref.chromatogramData,
      caretPosition = _ref.caretPosition,
      seqToInsert = _ref.seqToInsert,
      justBaseCalls = _ref.justBaseCalls;

  if (!seqToInsert.length) return;

  chromatogramData.baseCalls && (_chromatogramData$bas = chromatogramData.baseCalls).splice.apply(_chromatogramData$bas, [caretPosition, 0].concat(seqToInsert.split("")));
  if (justBaseCalls) {
    //return early if just base calls
    return chromatogramData;
  }

  var baseTracesToInsert = [];
  var qualNumsToInsert = [];

  for (var index = 0; index < seqToInsert.length; index++) {
    qualNumsToInsert.push(0);
    var toPush = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    baseTracesToInsert.push({
      aTrace: toPush,
      cTrace: toPush,
      gTrace: toPush,
      tTrace: toPush
    });
  }

  chromatogramData.baseTraces && (_chromatogramData$bas2 = chromatogramData.baseTraces).splice.apply(_chromatogramData$bas2, [caretPosition, 0].concat(baseTracesToInsert));
  chromatogramData.qualNums && (_chromatogramData$qua = chromatogramData.qualNums).splice.apply(_chromatogramData$qua, [caretPosition, 0].concat(qualNumsToInsert));

  return chromatogramData;
}

function trimChromatogram(_ref2) {
  var chromatogramData = _ref2.chromatogramData,
      _ref2$range = _ref2.range,
      start = _ref2$range.start,
      end = _ref2$range.end,
      justBaseCalls = _ref2.justBaseCalls;

  ["baseCalls"].concat(justBaseCalls ? [] : ["qualNums", "baseTraces", "basePos"]).forEach(function (type) {
    chromatogramData[type] && chromatogramData[type].splice(start, end - start + 1);
  });

  return chromatogramData;
}