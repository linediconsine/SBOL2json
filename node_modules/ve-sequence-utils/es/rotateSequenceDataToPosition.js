var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require("lodash"),
    map = _require.map;

var _require2 = require("ve-range-utils"),
    adjustRangeToRotation = _require2.adjustRangeToRotation;

var tidyUpSequenceData = require("./tidyUpSequenceData");
var modifiableTypes = require("./annotationTypes").modifiableTypes;
var rotateBpsToPosition = require("./rotateBpsToPosition");

module.exports = function rotateSequenceDataToPosition(sequenceData, caretPosition) {
  var newSequenceData = tidyUpSequenceData(sequenceData);

  //update the sequence
  newSequenceData.sequence = rotateBpsToPosition(newSequenceData.sequence, caretPosition);

  //handle the insert
  modifiableTypes.forEach(function (annotationType) {
    //update the annotations:
    //handle the delete if necessary
    newSequenceData[annotationType] = adjustAnnotationsToRotation(newSequenceData[annotationType], caretPosition, newSequenceData.sequence.length);
  });
  return newSequenceData;
};

function adjustAnnotationsToRotation(annotationsToBeAdjusted, positionToRotateTo, maxLength) {
  return map(annotationsToBeAdjusted, function (annotation) {
    return _extends({}, adjustRangeToRotation(annotation, positionToRotateTo, maxLength), {
      locations: annotation.locations ? annotation.locations.map(function (location) {
        return adjustRangeToRotation(location, positionToRotateTo, maxLength);
      }) : undefined
    });
  }).filter(function (range) {
    return !!range;
  }); //filter any fully deleted ranges
}