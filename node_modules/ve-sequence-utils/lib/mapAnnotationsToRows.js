"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require("lodash"),
    each = _require.each,
    forEach = _require.forEach,
    startsWith = _require.startsWith,
    filter = _require.filter;

var _require2 = require("ve-range-utils"),
    getYOffsetForPotentiallyCircularRange = _require2.getYOffsetForPotentiallyCircularRange,
    splitRangeIntoTwoPartsIfItIsCircular = _require2.splitRangeIntoTwoPartsIfItIsCircular;

module.exports = function mapAnnotationsToRows(annotations, sequenceLength, bpsPerRow) {
  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      splitForwardReverse = _ref.splitForwardReverse;

  var annotationsToRowsMap = {};
  var yOffsetLevelMap = {};
  var wrappedAnnotations = {};
  each(annotations, function (annotation) {
    var containsLocations = !!(annotation.locations && annotation.locations.length);
    if (annotation.overlapsSelf) {
      //if the annotation overlaps itself, first send a fake full spanning annotation thru the mapping function
      if (!wrappedAnnotations[annotation.id]) {
        mapAnnotationToRows({
          wrappedAnnotations: wrappedAnnotations,
          annotation: {
            start: 0,
            end: sequenceLength - 1,
            id: "__tempAnnRemoveMe__" + annotation.id
          },
          sequenceLength: sequenceLength,
          bpsPerRow: bpsPerRow,
          annotationsToRowsMap: annotationsToRowsMap,
          yOffsetLevelMap: yOffsetLevelMap,
          containsLocations: containsLocations,
          splitForwardReverse: splitForwardReverse
        });
        wrappedAnnotations[annotation.id] = true;
        // annotation.yOffset = wrappedAnnotations[annotation.id];
      }
    }

    mapAnnotationToRows({
      wrappedAnnotations: wrappedAnnotations,
      annotation: annotation,
      sequenceLength: sequenceLength,
      bpsPerRow: bpsPerRow,
      annotationsToRowsMap: annotationsToRowsMap,
      yOffsetLevelMap: yOffsetLevelMap,
      containsLocations: containsLocations,
      splitForwardReverse: splitForwardReverse
    });
    if (containsLocations) {
      annotation.locations.forEach(function (location) {
        mapAnnotationToRows({
          wrappedAnnotations: wrappedAnnotations,
          annotation: annotation,
          sequenceLength: sequenceLength,
          bpsPerRow: bpsPerRow,
          annotationsToRowsMap: annotationsToRowsMap,
          yOffsetLevelMap: yOffsetLevelMap,
          location: location,
          splitForwardReverse: splitForwardReverse
        });
      });
    }
  });
  forEach(annotationsToRowsMap, function (annotationsForRow, i) {
    annotationsToRowsMap[i] = filter(annotationsForRow, function (ann) {
      return !startsWith(ann.id, "__tempAnnRemoveMe__");
    });
  });
  return annotationsToRowsMap;
};

function mapAnnotationToRows(_ref2) {
  var wrappedAnnotations = _ref2.wrappedAnnotations,
      annotation = _ref2.annotation,
      sequenceLength = _ref2.sequenceLength,
      bpsPerRow = _ref2.bpsPerRow,
      annotationsToRowsMap = _ref2.annotationsToRowsMap,
      yOffsetLevelMap = _ref2.yOffsetLevelMap,
      location = _ref2.location,
      containsLocations = _ref2.containsLocations,
      splitForwardReverse = _ref2.splitForwardReverse;

  var ranges = splitRangeIntoTwoPartsIfItIsCircular(location || annotation, sequenceLength);
  ranges.forEach(function (range, index) {
    // if (!isPositiveInteger(range.start)) {}
    var startingRow = Math.floor(range.start / bpsPerRow);
    var endingRow = Math.floor(range.end / bpsPerRow);
    // const numberOfRows = endingRow - startingRow + 1;
    for (var rowNumber = startingRow; rowNumber <= endingRow; rowNumber++) {
      if (!annotationsToRowsMap[rowNumber]) {
        annotationsToRowsMap[rowNumber] = [];
      }
      var key = splitForwardReverse ? annotation.forward ? rowNumber + "_forward" : rowNumber + "_reverse" : rowNumber;

      var annotationsForRow = annotationsToRowsMap[rowNumber];
      if (!yOffsetLevelMap[key]) {
        yOffsetLevelMap[key] = [];
      }

      var yOffset = void 0;
      var yOffsetsForRow = yOffsetLevelMap[key];
      var start = rowNumber === startingRow ? range.start : rowNumber * bpsPerRow;
      var end = rowNumber === endingRow ? range.end : rowNumber * bpsPerRow + bpsPerRow - 1;
      if (annotation.overlapsSelf) {
        annotationsForRow.forEach(function (ann) {
          if (ann.id === "__tempAnnRemoveMe__" + annotation.id) {
            yOffset = ann.yOffset;
          }
        });
      } else {
        if (location) {
          //if there's a location then we will just use the previous yOffset for its parent annotation
          annotationsForRow.forEach(function (ann) {
            if (ann.id === annotation.id) {
              yOffset = ann.yOffset;
            }
          });
        } else {
          //we need to pass both ranges into this function so that we can correctly
          //get the y-offset for circular features that start and end on the same row
          //we pass the entire annotation range here and compare it only with ranges that have already been added to the row
          if (index > 0 && //second half of an annotation range
          annotationsForRow.length && //there are already annotations within the row
          annotationsForRow[annotationsForRow.length - 1].annotation === annotation) {
            //the first chunk of the annotation has already been pushed into the row,
            //so set the yOffset for the range chunk to the already calculated yOffset
            yOffset = annotationsForRow[annotationsForRow.length - 1].yOffset;
          } else {
            yOffset = getYOffsetForPotentiallyCircularRange(annotation, yOffsetsForRow);
          }
          //add the new yOffset to the yOffset array
          if (!yOffsetsForRow[yOffset]) yOffsetsForRow[yOffset] = [];
          yOffsetsForRow[yOffset].push({
            start: start,
            end: end
          });
        }
      }

      annotationsForRow.push(_extends({
        id: annotation.id,
        annotation: annotation,
        start: start,
        end: end
      }, containsLocations && { containsLocations: containsLocations }, location && { isJoinedLocation: !!location }, {
        yOffset: yOffset,
        enclosingRangeType: range.type //either "beginning", "end" or "beginningAndEnd"
      }));
    }
  });
  // return annotationsToRowsMap;
}