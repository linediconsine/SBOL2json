"use strict";

// const getAllInsertionsInSeqReads = require("./getAllInsertionsInSeqReads.js");
var insertGapsIntoRefSeq = require("./insertGapsIntoRefSeq.js");

var _require = require("lodash"),
    cloneDeep = _require.cloneDeep;

// bam.seq: NTGTAAGTCGTGAAAAAANCNNNCATATTNCGGAGGTAAAAATGAAAA...
// bam.pos: 43
// bam.cigar: 36M2D917M3I17M7I2M1I6M5I4M1D6M12I8M
// (note: bam.cigar is null if the sequencing read is unaligned)
// bam.reversed: true (if reversed)

// refSeq should be an object { name, sequence }
// seqReads should be an array of objects [{name, seq, pos, cigar}, {name, seq, pos, cigar}, ...]
// add gaps into sequencing reads before starting bp pos and from own deletions & all seq reads' insertions, minus own insertions


module.exports = function addGapsToSeqReads(refSeq, seqReads) {
  // remove unaligned seq reads for now
  for (var i = 0; i < seqReads.length; i++) {
    if (seqReads[i].cigar === null) {
      seqReads.splice(i, 1);
    }
  }

  var refSeqWithGaps = insertGapsIntoRefSeq(refSeq.sequence, seqReads);
  // first object is reference sequence with gaps, to be followed by seq reads with gaps
  var seqReadsWithGaps = [{ name: refSeq.name, sequence: refSeqWithGaps.toUpperCase() }];
  seqReads.forEach(function (seqRead) {
    // get all insertions in seq reads
    var allInsertionsInSeqReads = [];
    seqReads.forEach(function (seqRead) {
      // split cigar string at S, M, D, or I (soft-clipped, match, deletion, or insertion), e.g. ["5S", "2M", "3I", "39M", "3D"..."9S"]
      var splitSeqRead = seqRead.cigar.match(/([0-9]*[SMDI])/g);
      // adjust seqRead.pos, aka bp pos where the seq read starts aligning to the ref seq, if bps have been soft-clipped from the beginning of the seq read
      var adjustedSeqReadPos = cloneDeep(seqRead.pos);
      if (splitSeqRead[0].slice(-1) === "S") {
        // # in #S at beginning of array, i.e. number of soft-clipped base pairs at beginning of the seq read
        var numOfBeginningSoftClipped = splitSeqRead[0].slice(0, -1);
        adjustedSeqReadPos = seqRead.pos - numOfBeginningSoftClipped;
      }
      for (var componentI = 0; componentI < splitSeqRead.length; componentI++) {
        if (splitSeqRead[componentI].slice(-1) === "I") {
          var bpPosOfInsertion = adjustedSeqReadPos;
          var numberOfInsertions = Number(splitSeqRead[componentI].slice(0, -1));
          for (var _i = 0; _i < componentI; _i++) {
            if (splitSeqRead[_i].slice(-1) !== "I") {
              var previousComponentNumber = Number(splitSeqRead[_i].slice(0, -1));
              bpPosOfInsertion += previousComponentNumber;
            }
          }
          var insertionInfo = {
            // keeping bpPos 1-based
            bpPos: bpPosOfInsertion,
            number: numberOfInsertions
          };
          allInsertionsInSeqReads.push(insertionInfo);
        }
      }
    });

    // 1) add gaps before starting bp pos
    var splitSeqReadChunk = seqRead.cigar.match(/([0-9]*[SMDI])/g);
    var adjustedSeqReadPos = cloneDeep(seqRead.pos);
    if (splitSeqReadChunk[0].slice(-1) === "S") {
      // # in #S at beginning of array, i.e. number of soft-clipped base pairs at beginning of the seq read
      var numOfBeginningSoftClipped = splitSeqReadChunk[0].slice(0, -1);
      adjustedSeqReadPos = seqRead.pos - numOfBeginningSoftClipped;
    }
    var eachSeqReadWithGaps = seqRead.seq.split("");
    if (adjustedSeqReadPos > 0) {
      eachSeqReadWithGaps.unshift("-".repeat(adjustedSeqReadPos - 1));
    }
    eachSeqReadWithGaps = eachSeqReadWithGaps.join("").split("");

    // 2) add own deletions to own sequence
    // get own deletions
    var ownDeletions = [];
    for (var componentI = 0; componentI < splitSeqReadChunk.length; componentI++) {
      if (splitSeqReadChunk[componentI].slice(-1) === "D") {
        var bpPosOfDeletion = adjustedSeqReadPos;
        var numberOfDeletions = Number(splitSeqReadChunk[componentI].slice(0, -1));
        for (var _i2 = 0; _i2 < componentI; _i2++) {
          var previousComponentNumber = Number(splitSeqReadChunk[_i2].slice(0, -1));
          bpPosOfDeletion += previousComponentNumber;
        }
        var deletionInfo = {
          // keeping bpPos 1-based
          bpPos: bpPosOfDeletion,
          number: numberOfDeletions
        };
        ownDeletions.push(deletionInfo);
      }
    }
    // sort deletions by ascending bp pos
    var sortedOwnDeletions = ownDeletions.sort(function (a, b) {
      return a.bpPos - b.bpPos;
    });
    // add own deletions to own sequence
    for (var ownD = 0; ownD < sortedOwnDeletions.length; ownD++) {
      var _bpPosOfDeletion = sortedOwnDeletions[ownD].bpPos;
      var _numberOfDeletions = sortedOwnDeletions[ownD].number;
      // adding gaps at the bp pos
      var deletionGaps = "";
      for (var gapD = 0; gapD < _numberOfDeletions; gapD++) {
        deletionGaps += "-";
      }
      eachSeqReadWithGaps.splice(_bpPosOfDeletion - 1, 0, deletionGaps);
      eachSeqReadWithGaps = eachSeqReadWithGaps.join("").split("");
    }
    eachSeqReadWithGaps = eachSeqReadWithGaps.join("").split("");

    // 3) remove own insertions from own sequence
    // get own insertions
    var ownInsertions = [];
    var ownInsertionsBp = [];
    for (var _componentI = 0; _componentI < splitSeqReadChunk.length; _componentI++) {
      if (splitSeqReadChunk[_componentI].slice(-1) === "I") {
        var bpPosOfInsertion = adjustedSeqReadPos;
        var numberOfInsertions = Number(splitSeqReadChunk[_componentI].slice(0, -1));
        var nucleotides = [];
        for (var _i3 = 0; _i3 < _componentI; _i3++) {
          var _previousComponentNumber = Number(splitSeqReadChunk[_i3].slice(0, -1));
          bpPosOfInsertion += _previousComponentNumber;
        }
        for (var nucI = 0; nucI < numberOfInsertions; nucI++) {
          nucleotides.push(eachSeqReadWithGaps[bpPosOfInsertion - 1 + nucI]);
        }
        var insertionInfo = {
          // keeping bpPos 1-based
          bpPos: bpPosOfInsertion,
          number: numberOfInsertions
        };
        var insertionInfoBp = {
          // keeping bpPos 1-based
          bpPos: bpPosOfInsertion,
          number: numberOfInsertions,
          nucleotides: nucleotides
        };
        ownInsertions.push(insertionInfo);
        ownInsertionsBp.push(insertionInfoBp);
      }
    }
    var ownInsertionsCompare = JSON.parse(JSON.stringify(ownInsertions));
    // sort own insertions by ascending bp pos
    var sortedOwnInsertions = ownInsertions.sort(function (a, b) {
      return a.bpPos - b.bpPos;
    });
    var sortedOwnInsertionsBp = ownInsertionsBp.sort(function (a, b) {
      return a.bpPos - b.bpPos;
    });
    // remove own insertions from own sequence
    for (var ownI = 0; ownI < sortedOwnInsertions.length; ownI++) {
      var _bpPosOfInsertion = sortedOwnInsertions[ownI].bpPos;
      var _numberOfInsertions = sortedOwnInsertions[ownI].number;
      for (var numI = 0; numI < _numberOfInsertions; numI++) {
        eachSeqReadWithGaps.splice(_bpPosOfInsertion - 1, 1);
      }
      for (var posI = ownI + 1; posI < sortedOwnInsertions.length; posI++) {
        sortedOwnInsertions[posI].bpPos -= _numberOfInsertions;
      }
    }

    // 4) add other seq reads' insertions to seq read
    // get other seq reads' insertions (i.e. all insertions minus duplicates minus own insertions)
    var otherInsertions = allInsertionsInSeqReads.sort(function (a, b) {
      return a.bpPos - b.bpPos;
    });
    // combine duplicates within all insertions, remove own insertions from all insertions, combine overlap between other insertions & own insertions
    // first, combine duplicates within all insertions
    otherInsertions = otherInsertions.filter(function (object, index) {
      return index === otherInsertions.findIndex(function (obj) {
        return JSON.stringify(obj) === JSON.stringify(object);
      });
    });
    // 'i < otherInsertions.length - 1' because when at the end of the array, there is no 'i + 1' to compare to
    for (var _i4 = 0; _i4 < otherInsertions.length - 1; _i4++) {
      while (otherInsertions[_i4].bpPos === otherInsertions[_i4 + 1].bpPos) {
        if (otherInsertions[_i4].number > otherInsertions[_i4 + 1].number) {
          // remove the one with fewer number of gaps from array
          otherInsertions.splice(_i4 + 1, 1);
        } else if (otherInsertions[_i4].number < otherInsertions[_i4 + 1].number) {
          otherInsertions.splice(_i4, 1);
        } else if (otherInsertions[_i4].number === otherInsertions[_i4 + 1].number) {
          otherInsertions.splice(_i4, 1);
        }
      }
    }
    // then remove own insertions from all insertions

    var _loop = function _loop(_otherI) {
      var insertionInfoIndex = otherInsertions.findIndex(function (e) {
        return e.bpPos === ownInsertionsCompare[_otherI].bpPos;
      });
      if (insertionInfoIndex !== -1) {
        if (otherInsertions[insertionInfoIndex].number > ownInsertionsCompare[_otherI].number) {
          otherInsertions[insertionInfoIndex].number = otherInsertions[insertionInfoIndex].number - ownInsertionsCompare[_otherI].number;
        } else if (otherInsertions[insertionInfoIndex].number <= ownInsertionsCompare[_otherI].number) {
          otherInsertions.splice(insertionInfoIndex, 1);
          _otherI--;
        }
      }
      otherI = _otherI;
    };

    for (var otherI = 0; otherI < ownInsertionsCompare.length; otherI++) {
      _loop(otherI);
    }
    // then combine overlap between other insertions & own insertions

    var _loop2 = function _loop2(_overlapI) {
      var insertionInfoIndex = otherInsertions.findIndex(function (e) {
        return e.bpPos === sortedOwnInsertions[_overlapI].bpPos;
      });
      if (insertionInfoIndex !== -1) {
        if (otherInsertions[insertionInfoIndex].number > sortedOwnInsertions[_overlapI].number) {
          otherInsertions[insertionInfoIndex].number = otherInsertions[insertionInfoIndex].number - sortedOwnInsertions[_overlapI].number;
        } else if (otherInsertions[insertionInfoIndex].number <= sortedOwnInsertions[_overlapI].number) {
          otherInsertions.splice(insertionInfoIndex, 1);
          _overlapI--;
        }
      }
      overlapI = _overlapI;
    };

    for (var overlapI = 0; overlapI < sortedOwnInsertions.length; overlapI++) {
      _loop2(overlapI);
    }
    // adjust own insertions according to other seq reads' insertions to be added (i.e. for all other reads' insertions with smaller bp pos, +1 to that own insertion's bp pos)
    var adjustedOwnInsertionsBp = JSON.parse(JSON.stringify(sortedOwnInsertionsBp));
    for (var _ownI = 0; _ownI < adjustedOwnInsertionsBp.length; _ownI++) {
      var previousInserts = 0;
      for (var _i5 = 0; _i5 < _ownI; _i5++) {
        previousInserts += adjustedOwnInsertionsBp[_i5].number - 1;
      }
      adjustedOwnInsertionsBp[_ownI].bpPos = adjustedOwnInsertionsBp[_ownI].bpPos - previousInserts;
      sortedOwnInsertionsBp[_ownI].bpPos = sortedOwnInsertionsBp[_ownI].bpPos - previousInserts;
    }
    for (var otherI = 0; otherI < otherInsertions.length; otherI++) {
      for (var _ownI2 = 0; _ownI2 < adjustedOwnInsertionsBp.length; _ownI2++) {
        if (otherInsertions[otherI].bpPos <= sortedOwnInsertionsBp[_ownI2].bpPos) {
          adjustedOwnInsertionsBp[_ownI2].bpPos += 1;
        }
      }
    }
    // add other seq reads' insertions to sequence
    for (var _otherI2 = 0; _otherI2 < otherInsertions.length && otherInsertions[_otherI2].bpPos <= eachSeqReadWithGaps.length; _otherI2++) {
      var _bpPosOfInsertion2 = otherInsertions[_otherI2].bpPos;
      var _numberOfInsertions2 = otherInsertions[_otherI2].number;
      // adding gaps at the bp pos
      var insertionGaps = "";
      for (var gapI = 0; gapI < _numberOfInsertions2; gapI++) {
        insertionGaps += "-";
      }
      eachSeqReadWithGaps.splice(_bpPosOfInsertion2 - 1, 0, insertionGaps);
      for (var _posI = _otherI2 + 1; _posI < otherInsertions.length; _posI++) {
        otherInsertions[_posI].bpPos += 1;
      }
    }

    // 5) add own insertions to own sequence
    for (var _ownI3 = 0; _ownI3 < adjustedOwnInsertionsBp.length; _ownI3++) {
      var _bpPosOfInsertion3 = adjustedOwnInsertionsBp[_ownI3].bpPos;
      var _nucleotides = adjustedOwnInsertionsBp[_ownI3].nucleotides.join("");
      eachSeqReadWithGaps.splice(_bpPosOfInsertion3 - 1, 0, _nucleotides);
    }

    // 6) add gaps after seq read for ref seq's length = seq read's length
    eachSeqReadWithGaps = eachSeqReadWithGaps.join("").split("");
    if (eachSeqReadWithGaps.length < refSeqWithGaps.length) {
      eachSeqReadWithGaps.push("-".repeat(refSeqWithGaps.length - eachSeqReadWithGaps.length));
    }

    // eachSeqReadWithGaps is a string "GGGA--GA-C--ACC"
    seqReadsWithGaps.push({
      name: seqRead.name,
      sequence: eachSeqReadWithGaps.join(""),
      reversed: seqRead.reversed,
      cigar: seqRead.cigar
    });
  });

  // 7) add gaps before starting bp pos
  // add gaps based on any seq reads that extend beyond beginning of the ref seq due to soft-clipped reads
  // a) get the lengths of bps that extend beyond the beginning of the ref seq among all seq reads
  var seqReadLengthsBeforeRefSeqStart = [];
  seqReads.forEach(function (seq) {
    var splitSeqReadChunk = seq.cigar.match(/([0-9]*[SMDI])/g);
    var adjustedSeqReadPos = cloneDeep(seq.pos);
    if (splitSeqReadChunk[0].slice(-1) === "S") {
      // # in #S at beginning of array, i.e. number of soft-clipped base pairs at beginning of the seq read
      var numOfBeginningSoftClipped = splitSeqReadChunk[0].slice(0, -1);
      adjustedSeqReadPos = seq.pos - numOfBeginningSoftClipped;
      // number of gaps to add if soft-clipped reads extend beyond beginning of ref seq
      if (adjustedSeqReadPos < 0) {
        seqReadLengthsBeforeRefSeqStart.push(Math.abs(adjustedSeqReadPos));
      }
    }
    // number of gaps to add if seqRead.pos is negative (not sure if this is possible with bowtie2 outputs)
    // if (seq.pos < 0) {
    //   seqReadLengthsBeforeRefSeqStart.push(Math.abs(seq.pos))
    // }
  });
  // b) add gaps (to both ref seq and seq reads) based on any seq reads that extend beyond beginning of ref seq due to soft-clipped reads
  var longestSeqReadLength = 0;
  for (var _i6 = 1; _i6 < seqReadsWithGaps.length; _i6++) {
    // turn seq read into an array ["A", "T", "C", "G"...]
    var eachSeqReadWithGaps = seqReadsWithGaps[_i6].sequence.split("");
    var splitSeqReadChunk = seqReads[_i6 - 1].cigar.match(/([0-9]*[SMDI])/g);
    var adjustedSeqReadPos = cloneDeep(seqReads[_i6 - 1].pos);
    // longest length of bps that extend beyond the beginning of the ref seq among all seq reads
    if (seqReadLengthsBeforeRefSeqStart.length > 0) {
      longestSeqReadLength = Math.max.apply(Math, seqReadLengthsBeforeRefSeqStart);
    }
    if (splitSeqReadChunk[0].slice(-1) === "S") {
      // # in #S at beginning of array, i.e. number of soft-clipped base pairs at beginning of the seq read
      var numOfBeginningSoftClipped = splitSeqReadChunk[0].slice(0, -1);
      adjustedSeqReadPos = seqReads[_i6 - 1].pos - numOfBeginningSoftClipped;
      if (adjustedSeqReadPos > 0) {
        if (longestSeqReadLength > 0) {
          eachSeqReadWithGaps.unshift("-".repeat(longestSeqReadLength + 1));
        }
        seqReadsWithGaps[_i6].sequence = eachSeqReadWithGaps.join("");
      } else if (adjustedSeqReadPos < 0) {
        if (longestSeqReadLength > 0) {
          eachSeqReadWithGaps.unshift("-".repeat(longestSeqReadLength - Math.abs(adjustedSeqReadPos)));
        }
        seqReadsWithGaps[_i6].sequence = eachSeqReadWithGaps.join("");
      }
    } else {
      if (longestSeqReadLength > 0) {
        eachSeqReadWithGaps.unshift("-".repeat(longestSeqReadLength + 1));
      }
      seqReadsWithGaps[_i6].sequence = eachSeqReadWithGaps.join("");
    }
  }

  // add gaps before ref seq based on the longest length of soft-clipped reads that extend beyond beginning of ref seq
  if (longestSeqReadLength > 0) {
    var splitRefSeqWithGaps = seqReadsWithGaps[0].sequence.split("");
    splitRefSeqWithGaps.unshift("-".repeat(longestSeqReadLength + 1));
    seqReadsWithGaps[0].sequence = splitRefSeqWithGaps.join("");
  }

  // 8) check if any seq read is longer than the ref seq, make ref seq & seq reads all the same length
  var lengthsOfLongerSeqReads = [];
  for (var _i7 = 1; _i7 < seqReadsWithGaps.length; _i7++) {
    var _refSeq = seqReadsWithGaps[0];
    if (seqReadsWithGaps[_i7].sequence.length > _refSeq.sequence.length) {
      lengthsOfLongerSeqReads.push(seqReadsWithGaps[_i7].sequence.length);
    }
  }
  if (lengthsOfLongerSeqReads.length > 0) {
    var _longestSeqReadLength = Math.max.apply(Math, lengthsOfLongerSeqReads);
    for (var _i8 = 0; _i8 < seqReadsWithGaps.length; _i8++) {
      if (seqReadsWithGaps[_i8].sequence.length < _longestSeqReadLength) {
        seqReadsWithGaps[_i8].sequence += "-".repeat(_longestSeqReadLength - seqReadsWithGaps[_i8].sequence.length);
      }
    }
  }
  // if any seq read shorter than ref seq, make ref seq & seq reads all the same length
  for (var _i9 = 1; _i9 < seqReadsWithGaps.length; _i9++) {
    var _refSeq2 = seqReadsWithGaps[0];
    if (seqReadsWithGaps[_i9].sequence.length < _refSeq2.sequence.length) {
      seqReadsWithGaps[_i9].sequence += "-".repeat(_refSeq2.sequence.length - seqReadsWithGaps[_i9].sequence.length);
    }
  }

  // seqReadsWithGaps is an array of objects containing the ref seq with gaps first and then all seq reads with gaps
  // e.g. [{ name: "ref seq", sequence: "GG---GA--GA-C--A---CC---"}, { name: "r1", sequence: "-----GATTGA-C-----------"}...]
  // console.log('seqReadsWithGaps:',seqReadsWithGaps)
  return seqReadsWithGaps;
};