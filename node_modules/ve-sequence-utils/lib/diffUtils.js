"use strict";

var _require = require("lodash"),
    cloneDeep = _require.cloneDeep,
    forEach = _require.forEach;

var tidyUpSequenceData = require("./tidyUpSequenceData");
var differ = require("jsondiffpatch").create({
  // cloneDiffValues: true
});

var getDiffFromSeqs = function getDiffFromSeqs(oldData, newData) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$ignoreKeys = _ref.ignoreKeys,
      ignoreKeys = _ref$ignoreKeys === undefined ? [] : _ref$ignoreKeys;

  oldData = tidyUpSequenceData(oldData, {
    annotationsAsObjects: true,
    noTranslationData: true
  });
  newData = tidyUpSequenceData(newData, {
    annotationsAsObjects: true,
    noTranslationData: true
  });

  [oldData, newData].forEach(function (d) {
    ["cutsites", "orfs", "filteredFeatures", "size", "fromFileUpload", "description", "materiallyAvailable"].concat(ignoreKeys).forEach(function (prop) {
      delete d[prop];
    });
    if (d.translations) {
      forEach(d.translations, function (translation, key) {
        if (translation.translationType && translation.translationType !== "User Created") {
          delete d.translations[key];
        } else {
          delete translation.aminoAcids;
        }
      });
    }
  });

  return differ.diff(oldData, newData);
};
var patchSeqWithDiff = function patchSeqWithDiff(oldData, diff) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$ignoreKeys = _ref2.ignoreKeys,
      ignoreKeys = _ref2$ignoreKeys === undefined ? [] : _ref2$ignoreKeys;

  ignoreKeys.forEach(function (k) {
    delete diff[k];
  });
  return differ.patch(tidyUpSequenceData(cloneDeep(oldData), { annotationsAsObjects: true }), diff);
};
var reverseSeqDiff = function reverseSeqDiff(diff) {
  return differ.reverse(diff);
};

module.exports = { getDiffFromSeqs: getDiffFromSeqs, patchSeqWithDiff: patchSeqWithDiff, reverseSeqDiff: reverseSeqDiff };