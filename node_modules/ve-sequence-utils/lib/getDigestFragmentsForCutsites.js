"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require("ve-range-utils"),
    normalizePositionByRangeLength = _require.normalizePositionByRangeLength,
    getRangeLength = _require.getRangeLength;

module.exports = function getDigestFragmentsForCutsites(sequenceLength, circular, cutsites) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var fragments = [];
  var overlappingEnzymes = [];
  var pairs = [];
  if (!cutsites.length) return [];
  var sortedCutsites = cutsites.sort(function (a, b) {
    return a.topSnipPosition - b.topSnipPosition;
  });

  if (!circular) {
    //if linear, add 2 fake cutsites for the start and end of the seq
    sortedCutsites = [{
      topSnipPosition: 0,
      bottomSnipPosition: 0,
      overhangSize: 0,
      type: "START_OR_END_OF_SEQ",
      name: "START_OF_SEQ"
    }].concat(sortedCutsites, [{
      topSnipPosition: sequenceLength,
      bottomSnipPosition: sequenceLength,
      overhangSize: 0,
      type: "START_OR_END_OF_SEQ",
      name: "END_OF_SEQ"
    }]);
  }

  sortedCutsites.forEach(function (cutsite1, index) {
    if (!circular && !sortedCutsites[index + 1]) {
      return; //don't push a pair if the sequence is linear and we've reached the end of our cutsites array
    }
    if (opts.computePartialDigests) {
      sortedCutsites.forEach(function (cs, index2) {
        if (index2 === index + 1 || index2 === 0) {
          return;
        }
        pairs.push([cutsite1, sortedCutsites[index2]]);
      });
    }
    pairs.push([cutsite1, sortedCutsites[index + 1] ? sortedCutsites[index + 1] : sortedCutsites[0]]);
  });

  pairs.forEach(function (_ref) {
    var cut1 = _ref[0],
        cut2 = _ref[1];

    var start = normalizePositionByRangeLength(cut1.topSnipPosition, sequenceLength);
    var end = normalizePositionByRangeLength(cut2.topSnipPosition - 1, sequenceLength);
    var fragmentRange = { start: start, end: end };
    var size = getRangeLength(fragmentRange, sequenceLength);

    // const id = uniqid()
    var id = start + "-" + end + "-" + size + "-";

    // getRangeLength({ start, end }, sequenceLength);

    fragments.push(_extends({
      // I don't think we can determine containsFive/ThreePrimeRecognitionSite until the inclusion/exclusion of the overhangs is done
      // containsFivePrimeRecognitionSite: cut1.type !== "START_OR_END_OF_SEQ" && isRangeWithinRange(cut1.recognitionSiteRange, fragmentRange, sequenceLength ) ,
      // containsThreePrimeRecognitionSite: cut2.type !== "START_OR_END_OF_SEQ" && isRangeWithinRange(cut1.recognitionSiteRange,  fragmentRange, sequenceLength) ,
      cut1: _extends({}, cut1, {
        isOverhangIncludedInFragmentSize: cut1.type !== "START_OR_END_OF_SEQ" && cut1.overhangSize > 0 && cut1.topSnipBeforeBottom
      }),
      cut2: _extends({}, cut2, {
        isOverhangIncludedInFragmentSize: cut2.type !== "START_OR_END_OF_SEQ" && cut2.overhangSize > 0 && !cut2.topSnipBeforeBottom
      })
    }, fragmentRange, {
      size: size,
      id: id
    }));
  });

  fragments.filter(function (fragment) {
    if (!fragment.size) {
      overlappingEnzymes.push(fragment);
      return false;
    }
    return true;
  });
  return fragments;
};