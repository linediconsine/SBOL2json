"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require("lodash"),
    uniqBy = _require.uniqBy;

//UNDER CONSTRUCTION

var _require2 = require("ve-range-utils"),
    normalizePositionByRangeLength = _require2.normalizePositionByRangeLength,
    getRangeLength = _require2.getRangeLength;

module.exports = function getVirtualDigest(_ref) {
  var cutsites = _ref.cutsites,
      sequenceLength = _ref.sequenceLength,
      isCircular = _ref.isCircular,
      allowPartialDigests = _ref.allowPartialDigests;

  var fragments = [];
  var overlappingEnzymes = [];
  var pairs = [];
  var sortedCutsites = cutsites.sort(function (a, b) {
    return a.topSnipPosition - b.topSnipPosition;
  });

  sortedCutsites.forEach(function (cutsite1, index) {
    if (allowPartialDigests) {
      sortedCutsites.forEach(function (cutsite2, index2) {
        pairs.push([cutsite1, cutsite2]);
      });
    } else {
      pairs.push([cutsite1, sortedCutsites[index + 1] ? sortedCutsites[index + 1] : sortedCutsites[0]]);
    }
  });
  // pairs = uniqBy(pairs, ([cut1,cut2]) => {
  //   return cut1.topSnipPosition > cut2.topSnipPosition ? (cut1.name || "cut1") + "_" + (cut2.name || "cut2") :  (cut2.name || "cut2") + "_" + (cut1.name || "cut1")
  // })

  pairs.forEach(function (_ref2) {
    var cut1 = _ref2[0],
        cut2 = _ref2[1];

    var start = normalizePositionByRangeLength(cut1.topSnipPosition, sequenceLength);
    var end = normalizePositionByRangeLength(cut2.topSnipPosition - 1, sequenceLength);
    if (!isCircular && start > end) {
      //we have a fragment that spans the origin so we need to split it in 2 pieces
      var frag1 = {
        start: start,
        end: sequenceLength - 1,
        cut1: cut1,
        cut2: "endOfSeq"
      };
      var frag2 = {
        start: 0,
        end: end,
        cut1: "startOfSeq",
        cut2: cut2
      };

      fragments.push(addSizeAndId(frag1, sequenceLength));
      fragments.push(addSizeAndId(frag2, sequenceLength));
    } else {
      var frag = {
        cut1: cut1,
        cut2: cut2,
        start: start,
        end: end
      };
      fragments.push(addSizeAndId(frag, sequenceLength));
    }
  });
  // const sizeMap = {};
  fragments = fragments.filter(function (fragment) {
    if (!fragment.size) {
      overlappingEnzymes.push(fragment);
      return false;
    }
    // console.log('sizeMap:',sizeMap)
    // if (sizeMap[fragment.size]) {
    //   sizeMap[fragment.size].push(fragment);
    //   return false;
    // } else {
    //   sizeMap[fragment.size] = [fragment];
    // }
    return true;
  });
  return {
    fragments: fragments,
    overlappingEnzymes: overlappingEnzymes
  };
};

function addSizeAndId(frag, sequenceLength) {
  var size = getRangeLength({ start: frag.start, end: frag.end }, sequenceLength);
  return _extends({}, frag, {
    size: size,
    id: frag.start + "-" + frag.end + "-" + size + "-"
  });
}