"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require("lodash"),
    cloneDeep = _require.cloneDeep;

var FeatureTypes = require("./FeatureTypes.js");
var featureColors = require("./featureColors");
var bsonObjectid = require("bson-objectid");

module.exports = function tidyUpAnnotation(_annotation, _ref) {
  var _ref$sequenceData = _ref.sequenceData,
      sequenceData = _ref$sequenceData === undefined ? {} : _ref$sequenceData,
      convertAnnotationsFromAAIndices = _ref.convertAnnotationsFromAAIndices,
      annotationType = _ref.annotationType,
      provideNewIdsForAnnotations = _ref.provideNewIdsForAnnotations,
      doNotProvideIdsForAnnotations = _ref.doNotProvideIdsForAnnotations,
      _ref$messages = _ref.messages,
      messages = _ref$messages === undefined ? [] : _ref$messages,
      mutative = _ref.mutative;
  var size = sequenceData.size,
      circular = sequenceData.circular,
      isProtein = sequenceData.isProtein;

  if (!_annotation || (typeof _annotation === "undefined" ? "undefined" : _typeof(_annotation)) !== "object") {
    messages.push("Invalid annotation detected and removed");
    return false;
  }
  var annotation = _annotation;
  if (!mutative) {
    annotation = cloneDeep(_annotation);
  }
  annotation.annotationTypePlural = annotationType;

  if (!annotation.name || typeof annotation.name !== "string") {
    messages.push('Unable to detect valid name for annotation, setting name to "Untitled annotation"');
    annotation.name = "Untitled annotation";
  }
  if (provideNewIdsForAnnotations) {
    annotation.id = bsonObjectid().str;
  }
  if (!annotation.id && annotation.id !== 0 && !doNotProvideIdsForAnnotations) {
    annotation.id = bsonObjectid().str;
    messages.push("Unable to detect valid ID for annotation, setting ID to " + annotation.id);
  }

  //run this for the annotation itself
  coerceLocation({
    isProtein: isProtein,
    location: annotation,
    convertAnnotationsFromAAIndices: convertAnnotationsFromAAIndices,
    size: size,
    messages: messages,
    circular: circular,
    name: annotation.name
  });
  //and for each location
  annotation.locations && annotation.locations.forEach(function (location) {
    coerceLocation({
      isProtein: isProtein,
      location: location,
      convertAnnotationsFromAAIndices: convertAnnotationsFromAAIndices,
      size: size,
      messages: messages,
      circular: circular,
      name: annotation.name
    });
  });

  if (isProtein || annotation.forward === true || annotation.forward === "true" || annotation.strand === 1 || annotation.strand === "1" || annotation.strand === "+") {
    annotation.forward = true;
    annotation.strand = 1;
  } else {
    annotation.forward = false;
    annotation.strand = -1;
  }

  if (!annotation.type || typeof annotation.type !== "string" || !FeatureTypes.some(function (featureType) {
    if (featureType.toLowerCase() === annotation.type.toLowerCase()) {
      annotation.type = featureType; //this makes sure the annotation.type is being set to the exact value of the accepted featureType
      return true;
    }
    return false;
  })) {
    messages.push("Invalid annotation type detected:  " + annotation.type + " for " + annotation.name + ". set type to misc_feature");
    annotation.type = "misc_feature";
  }

  if (!annotation.color) {
    annotation.color = featureColors[annotation.type];
  }
  return annotation;
};

function coerceLocation(_ref2) {
  var location = _ref2.location,
      convertAnnotationsFromAAIndices = _ref2.convertAnnotationsFromAAIndices,
      size = _ref2.size,
      isProtein = _ref2.isProtein,
      messages = _ref2.messages,
      circular = _ref2.circular,
      name = _ref2.name;

  location.start = parseInt(location.start, 10);
  location.end = parseInt(location.end, 10);

  if (convertAnnotationsFromAAIndices) {
    location.start = location.start * 3;
    location.end = location.end * 3 + 2;
  }
  if (location.start < 0 || !(location.start <= size - 1) || location.start > size - 1) {
    messages.push("Invalid annotation start: " + location.start + " detected for " + location.name + " and set to size: " + size); //setting it to 0 internally, but users will see it as 1
    location.start = size - (isProtein ? 3 : 1);
  }
  if (location.end < 0 || !(location.end <= size - 1) || location.end > size - 1) {
    messages.push("Invalid annotation end:  " + location.end + " detected for " + location.name + " and set to seq size: " + size); //setting it to 0 internally, but users will see it as 1
    location.end = size - 1;
  }
  if (location.start > location.end && circular === false) {
    messages.push("Invalid circular annotation detected for " + name + ". end set to 1"); //setting it to 0 internally, but users will see it as 1
    location.end = size;
  }
}