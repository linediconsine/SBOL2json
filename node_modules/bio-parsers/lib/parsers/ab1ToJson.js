"use strict";

exports.__esModule = true;
exports.convertBasePosTraceToPerBpTrace = undefined;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ab1ToJson = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(fileObj) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var arrayBuffer, dataview, converter, chromatogramData, returnVal;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _getArrayBufferFromFile2.default)(fileObj);

          case 2:
            arrayBuffer = _context.sent;
            dataview = new DataView(arrayBuffer);
            converter = new abConverter(dataview);
            chromatogramData = converter.getTraceData();
            returnVal = (0, _createInitialSequence2.default)(options);

            returnVal.parsedSequence = _extends({}, returnVal.parsedSequence, {
              sequence: chromatogramData.baseCalls.join(""),
              chromatogramData: chromatogramData
            });
            return _context.abrupt("return", [returnVal]);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function ab1ToJson(_x) {
    return _ref.apply(this, arguments);
  };
}();

var _createInitialSequence = require("./utils/createInitialSequence");

var _createInitialSequence2 = _interopRequireDefault(_createInitialSequence);

var _getArrayBufferFromFile = require("./utils/getArrayBufferFromFile");

var _getArrayBufferFromFile2 = _interopRequireDefault(_getArrayBufferFromFile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = ab1ToJson;


function abConverter(inputArrayBuffer) {
  var dirLocation = inputArrayBuffer.getInt32(26);
  var numElements = inputArrayBuffer.getInt32(18);
  var lastEntry = dirLocation + numElements * 28;

  this.getNumber = function (inOffset, numEntries) {
    var retArray = [];
    for (var counter = 0; counter < numEntries; counter += 1) {
      retArray.push(inputArrayBuffer.getInt8(inOffset + counter));
    }
    return retArray;
  };

  this.getChar = function (inOffset, numEntries) {
    var retArray = [];
    for (var counter = 0; counter < numEntries; counter += 1) {
      retArray.push(String.fromCharCode(inputArrayBuffer.getInt8(inOffset + counter)));
    }
    return retArray;
  };

  this.getShort = function (inOffset, numEntries) {
    var retArray = [];
    for (var counter = 0; counter < numEntries; counter += 2) {
      retArray.push(inputArrayBuffer.getInt16(inOffset + counter));
    }
    return retArray;
  };

  this.getTagName = function (inOffset) {
    var name = "";
    for (var loopOffset = inOffset; loopOffset < inOffset + 4; loopOffset++) {
      name += String.fromCharCode(inputArrayBuffer.getInt8(loopOffset));
    }
    return name;
  };

  this.getDataTag = function (inTag) {
    var output = void 0;
    var curElem = dirLocation;
    do {
      var currTagName = this.getTagName(curElem);
      var tagNum = inputArrayBuffer.getInt32(curElem + 4);
      // eslint-disable-next-line eqeqeq
      if (currTagName == inTag.tagName && tagNum === inTag.tagNum) {
        var numEntries = inputArrayBuffer.getInt32(curElem + 16);
        var entryOffset = inputArrayBuffer.getInt32(curElem + 20);
        output = this[inTag.typeToReturn](entryOffset, numEntries);
      }
      curElem += 28;
    } while (curElem < lastEntry);
    return output;
  };

  this.getTraceData = function () {
    var traceData = {};
    traceData.aTrace = this.getDataTag(tagDict.colorDataA);
    traceData.tTrace = this.getDataTag(tagDict.colorDataT);
    traceData.gTrace = this.getDataTag(tagDict.colorDataG);
    traceData.cTrace = this.getDataTag(tagDict.colorDataC);
    traceData.basePos = this.getDataTag(tagDict.peakLocations);
    traceData.baseCalls = this.getDataTag(tagDict.baseCalls2);
    traceData.qualNums = this.getDataTag(tagDict.qualNums);
    if (traceData.qualNums) {
      //tnr if we're only getting 1's and 0's as qualNums, that means that there weren't actual qual nums attached to the file
      if (!traceData.qualNums.filter(function (q) {
        return q !== 1 && q !== 0;
      }).length) {
        delete traceData.qualNums;
      }
    }
    return convertBasePosTraceToPerBpTrace(traceData);
  };

  this.getFirstEntry = function () {
    var output = "";
    for (var curElem = dirLocation; curElem < lastEntry; curElem += 28) {
      var name = "";
      for (var offset = curElem; offset < curElem + 4; offset++) {
        name += String.fromCharCode(inputArrayBuffer.getInt8(offset));
      }
      output += " - " + name;
    }
    return output;
  };
}

var tagDict = {
  baseCalls1: { tagName: "PBAS", tagNum: 1, typeToReturn: "getChar" },
  baseCalls2: { tagName: "PBAS", tagNum: 2, typeToReturn: "getChar" },
  qualNums: { tagName: "PCON", tagNum: 2, typeToReturn: "getNumber" },
  peakLocations: { tagName: "PLOC", tagNum: 2, typeToReturn: "getShort" },
  peakDev: { tagName: "P1RL", tagNum: 1, typeToReturn: "getShort" },
  peakOneAmp: { tagName: "P1AM", tagNum: 1, typeToReturn: "getShort" },
  colorDataA: { tagName: "DATA", tagNum: 10, typeToReturn: "getShort" },
  colorDataT: { tagName: "DATA", tagNum: 11, typeToReturn: "getShort" },
  colorDataG: { tagName: "DATA", tagNum: 9, typeToReturn: "getShort" },
  colorDataC: { tagName: "DATA", tagNum: 12, typeToReturn: "getShort" }
};

var correctionAmount = 3;
// tnr: this function takes in chromData which has 4 traces and a basePos (which describes where in the trace the base call lands)
// It "normalizes" that data into a baseTraces array so that each base has its own set of that data (having a per-base trace makes insertion/deletion/copy/paste actions all easier)
function convertBasePosTraceToPerBpTrace(chromData) {
  var basePos = chromData.basePos,
      aTrace = chromData.aTrace;

  var traceLength = aTrace.length;
  var startPos = 0;
  var nextBasePos = basePos[1];
  var endPos = void 0;
  function setEndPos() {
    if (nextBasePos) {
      endPos = startPos + Math.ceil((nextBasePos - startPos) / 2);
    } else {
      endPos = traceLength;
    }
  }
  setEndPos();
  var baseTraces = [];

  var _loop = function _loop(i) {
    var tracesForType = {
      aTrace: [],
      tTrace: [],
      gTrace: [],
      cTrace: []
    };
    baseTraces[i] = tracesForType;
    ["aTrace", "tTrace", "gTrace", "cTrace"
    // eslint-disable-next-line no-loop-func
    ].forEach(function (type) {
      var traceForType = tracesForType[type];
      var traceData = chromData[type];
      for (var j = startPos; j < endPos + correctionAmount; j++) {
        traceForType.push(traceData[j] || 0);
      }
    });
    if (i !== basePos.length - 1) {
      startPos = endPos + correctionAmount;
      nextBasePos = basePos[i + 2];
      setEndPos();
    }
  };

  for (var i = 0; i < basePos.length; i++) {
    _loop(i);
  }

  return _extends({
    baseTraces: baseTraces
  }, chromData);
}

exports.convertBasePosTraceToPerBpTrace = convertBasePosTraceToPerBpTrace;