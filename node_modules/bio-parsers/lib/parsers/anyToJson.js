"use strict";

exports.__esModule = true;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * takes in file content string and its file name and determines what parser it needs to be sent to.
 * The file is parsed to our old JSON schema and after it goes through an intermediate step where we convert that json to our new schema
 * @param  {string} fileContentString content of the file as a string
 * @param  {Function} onFileParsed    //tnr: fill this out
 */

var anyToJson = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(fileContentStringOrFileObj, options) {
    var _this = this;

    var fileContentString, fileName, ext, parsersToTry, firstChar, _loop, _iterator, _isArray, _i, _ref2, parser, _ret, successfulParsing;

    return _regenerator2.default.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            successfulParsing = function successfulParsing(resultArray) {
              return resultArray.some(function (result) {
                return result.success;
              });
            };

            fileContentString = void 0;

            options = options || {};
            fileName = options.fileName || "";

            if (!fileName && typeof fileContentStringOrFileObj !== "string") {
              fileName = fileContentStringOrFileObj.name;
            }
            ext = (0, _extractFileExtension2.default)(fileName);

            if (!(typeof fileContentStringOrFileObj === "string")) {
              _context2.next = 10;
              break;
            }

            fileContentString = fileContentStringOrFileObj;
            _context2.next = 21;
            break;

          case 10:
            if (!/^(ab1)$/.test(ext)) {
              _context2.next = 14;
              break;
            }

            return _context2.abrupt("return", (0, _ab1ToJson2.default)(fileContentStringOrFileObj, options));

          case 14:
            if (!/^(dna)$/.test(ext)) {
              _context2.next = 18;
              break;
            }

            return _context2.abrupt("return", (0, _snapgeneToJson2.default)(fileContentStringOrFileObj, options));

          case 18:
            _context2.next = 20;
            return getUtf8StringFromFile(fileContentStringOrFileObj, options);

          case 20:
            fileContentString = _context2.sent;

          case 21:
            if (!/^(fasta|fas|fa|fna|ffn)$/.test(ext)) {
              _context2.next = 25;
              break;
            }

            return _context2.abrupt("return", (0, _fastaToJson2.default)(fileContentString, options));

          case 25:
            if (!/^(gb|gp|gbk)$/.test(ext)) {
              _context2.next = 29;
              break;
            }

            return _context2.abrupt("return", (0, _genbankToJson2.default)(fileContentString, options));

          case 29:
            if (!/^(gp)$/.test(ext)) {
              _context2.next = 33;
              break;
            }

            return _context2.abrupt("return", (0, _genbankToJson2.default)(fileContentString, _extends({}, options, { isProtein: true })));

          case 33:
            if (!/^(xml|rdf)$/.test(ext)) {
              _context2.next = 37;
              break;
            }

            return _context2.abrupt("return", (0, _sbolXmlToJson2.default)(fileContentStringOrFileObj, options));

          case 37:
            if (!/^(gff|gff3)$/.test(ext)) {
              _context2.next = 41;
              break;
            }

            return _context2.abrupt("return", (0, _gffToJson2.default)(fileContentStringOrFileObj, options));

          case 41:
            // console.warn(
            //   "TNR: No filename passed to anyToJson so we're going through the list of parsers. Make sure you're passing the filename when using anyToJson!"
            // );
            parsersToTry = [{
              fn: _genbankToJson2.default,
              name: "Genbank Parser"
            }, {
              fn: _fastaToJson2.default,
              name: "Fasta Parser"
            }];
            firstChar = fileContentString[fileContentString.search(/\S|$/)];

            //try to guess the file type based on the first non-whitespace char in the filestring

            if (firstChar === ">") {
              parsersToTry = parsersToTry.sort(function (a, b) {
                if (a.name === "Fasta Parser") return -1;
                return 1;
              });
            } else if (firstChar === "L") {
              parsersToTry = parsersToTry.sort(function (a, b) {
                if (a.name === "Genbank Parser") return -1;
                return 1;
              });
            }

            _loop = /*#__PURE__*/_regenerator2.default.mark(function _loop(parser) {
              var toReturn;
              return _regenerator2.default.wrap(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return parser.fn(fileContentString, options);

                    case 2:
                      toReturn = _context.sent;

                      if (!successfulParsing(toReturn)) {
                        _context.next = 6;
                        break;
                      }

                      //continue on to through the normal flow
                      toReturn.forEach(function (result) {
                        result.messages.push("Parsed using " + parser.name + ".");
                      });
                      return _context.abrupt("return", {
                        v: toReturn
                      });

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _loop, _this);
            });
            _iterator = parsersToTry, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 46:
            if (!_isArray) {
              _context2.next = 52;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context2.next = 49;
              break;
            }

            return _context2.abrupt("break", 63);

          case 49:
            _ref2 = _iterator[_i++];
            _context2.next = 56;
            break;

          case 52:
            _i = _iterator.next();

            if (!_i.done) {
              _context2.next = 55;
              break;
            }

            return _context2.abrupt("break", 63);

          case 55:
            _ref2 = _i.value;

          case 56:
            parser = _ref2;
            return _context2.delegateYield(_loop(parser), "t0", 58);

          case 58:
            _ret = _context2.t0;

            if (!((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object")) {
              _context2.next = 61;
              break;
            }

            return _context2.abrupt("return", _ret.v);

          case 61:
            _context2.next = 46;
            break;

          case 63:
            return _context2.abrupt("return", [{
              messages: ["Unable to parse .seq file as FASTA, genbank, JBEI, or SBOL formats"],
              success: false
            }]);

          case 64:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee, this);
  }));

  return function anyToJson(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var _fastaToJson = require("./fastaToJson");

var _fastaToJson2 = _interopRequireDefault(_fastaToJson);

var _genbankToJson = require("./genbankToJson");

var _genbankToJson2 = _interopRequireDefault(_genbankToJson);

var _sbolXmlToJson = require("./sbolXmlToJson");

var _sbolXmlToJson2 = _interopRequireDefault(_sbolXmlToJson);

var _extractFileExtension = require("./utils/extractFileExtension.js");

var _extractFileExtension2 = _interopRequireDefault(_extractFileExtension);

var _snapgeneToJson = require("./snapgeneToJson");

var _snapgeneToJson2 = _interopRequireDefault(_snapgeneToJson);

var _ab1ToJson = require("./ab1ToJson");

var _ab1ToJson2 = _interopRequireDefault(_ab1ToJson);

var _gffToJson = require("./gffToJson");

var _gffToJson2 = _interopRequireDefault(_gffToJson);

var _isBrowser = require("./utils/isBrowser");

var _isBrowser2 = _interopRequireDefault(_isBrowser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = anyToJson;


function getUtf8StringFromFile(file) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      emulateBrowser = _ref3.emulateBrowser;

  if (!_isBrowser2.default && !emulateBrowser) {
    //emulate browser is only used for testing purposes
    //we're in a node context
    return Buffer.isBuffer(file) ? file.toString("utf-8") : Buffer.isBuffer(file.buffer) ? file.buffer.toString("utf-8") : file;
  }
  var reader = new window.FileReader();
  reader.readAsText(file, "UTF-8");
  return new Promise(function (resolve, reject) {
    reader.onload = function (evt) {
      resolve(evt.target.result);
    };
    reader.onerror = function (err) {
      console.error("err:", err);
      reject(err);
    };
  });
}
module.exports = exports["default"];