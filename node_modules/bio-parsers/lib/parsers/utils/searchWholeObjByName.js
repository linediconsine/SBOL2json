'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = searchWholeObjByName;

var _lodash = require('lodash');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } //tnr: taken from https://github.com/angus-c/waldojs (not using waldojs as it is not being maintained and pulled in nasty babel runtime transforms)
/* eslint-disable eqeqeq */


var Match = function () {
  function Match(props) {
    _classCallCheck(this, Match);

    Object.assign(this, props);
    this.value = this.obj[this.prop];
  }

  Match.prototype.toString = function toString() {
    var path = this.path,
        type = this.type;

    return path + ' -> (' + type + ') ' + this.logValue();
  };

  Match.prototype.logValue = function logValue() {
    var val = this.value;
    // if value is an object then just toString it
    var isPrimitive = function isPrimitive(x) {
      return Object(x) !== x;
    };
    return isPrimitive(val) || Array.isArray(val) ? val : {}.toString.call(val);
  };

  Match.prototype.log = function log() {
    console.info(this.toString());
  };

  return Match;
}();

var GLOBAL = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' ? window : global;

function searchWholeObjByName(what, where) {
  var searchBy = function searchBy(what, where, prop) {
    return what == prop;
  };

  var data = void 0;
  var alreadySeen = void 0;

  var path = where == GLOBAL ? 'GLOBAL' : 'SRC';
  var queue = [{ where: where, path: path }];
  var seen = [];

  var matches = [];
  matches.log = function () {
    this.forEach(function (m) {
      return m.log();
    });
  };

  // a non-recursive solution to avoid call stack limits
  // http://www.jslab.dk/articles/non.recursive.preorder.traversal.part4
  while (data = queue.pop()) {
    var _data = data,
        _where = _data.where,
        _path = _data.path;


    for (var prop in _where) {
      // IE may throw errors when accessing/coercing some properties
      try {
        if (_where.hasOwnProperty(prop)) {
          // inspect objects
          if ([_where[prop]] == '[object Object]') {
            // check if already searched (prevents circular references)
            for (var i = -1; seen[++i] && !(alreadySeen = (0, _lodash.isEqual)(seen[i].where, _where[prop]) && seen[i]);) {}
            // add to stack
            if (!alreadySeen) {
              data = { where: _where[prop], path: _path + '.' + prop };
              queue.push(data);
              seen.push(data);
            }
          }
          // if match detected, push it.
          if (searchBy(what, _where, prop)) {
            var type = alreadySeen ? '<' + alreadySeen.path + '>' : _typeof(_where[prop]);
            var match = new Match({ path: _path + '.' + prop, obj: _where, prop: prop, type: type });
            matches.push(match);
          }
        }
      } catch (e) {}
    }
  }

  return matches;
}
module.exports = exports['default'];