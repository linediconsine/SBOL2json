"use strict";

exports.__esModule = true;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

//Here's what should be in the callback:
// {
//   parsedSequence:
//   messages:
//   success:
// }
var sbolXmlToJson = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(string, options) {
    var onFileParsed, response, result, sbolJsonMatches, resultArray, i;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = options || {};

            onFileParsed = function onFileParsed(sequences) {
              //before we call the onFileParsed callback, we need to validate the sequence
              return (0, _validateSequenceArray2.default)(sequences, options);
            };

            response = {
              parsedSequence: null,
              messages: [],
              success: true
            };
            _context.prev = 3;
            _context.next = 6;
            return new Promise(function (resolve, reject) {
              return (0, _xml2js.parseString)(string, function (err, result) {
                if (err) reject(err);else resolve(result);
              });
            });

          case 6:
            result = _context.sent;
            sbolJsonMatches = (0, _searchWholeObjByName2.default)("DnaComponent", result);

            if (!sbolJsonMatches[0]) {
              _context.next = 14;
              break;
            }

            resultArray = [];

            for (i = 0; i < sbolJsonMatches[0].value.length; i++) {
              try {
                response = {
                  parsedSequence: null,
                  messages: [],
                  success: true
                };
                response.parsedSequence = parseSbolJson(sbolJsonMatches[0].value[i], options);
              } catch (e) {
                console.error("error:", e);
                console.error("error.stack: ", e.stack);
                resultArray.push({
                  success: false,
                  messages: "Error while parsing Sbol format"
                });
              }
              if (response.parsedSequence.features.length > 0) {
                response.messages.push("SBOL feature types are stored in feature notes");
              }
              resultArray.push(response);
            }
            return _context.abrupt("return", onFileParsed(resultArray));

          case 14:
            return _context.abrupt("return", onFileParsed({
              success: false,
              messages: "XML is not valid Jbei or Sbol format"
            }));

          case 15:
            _context.next = 20;
            break;

          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](3);
            return _context.abrupt("return", onFileParsed({
              success: false,
              messages: "Error parsing XML to JSON"
            }));

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[3, 17]]);
  }));

  return function sbolXmlToJson(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
// Converts SBOL formats.
//  * Specifications for SBOL can be found at http://www.sbolstandard.org/specification/core-data-model
//  *
//  * The hierarcy of the components in an SBOL object is:
//  *
//  *          The hierarchy is Collection -> DnaComponent -> DnaSequence
//  *
//  * Check for each level and parse downward from there.
// tnrtodo: this should be tested with a wider variety of sbol file types!


var _xml2js = require("xml2js");

var _flatmap = require("flatmap");

var _flatmap2 = _interopRequireDefault(_flatmap);

var _safeAccess = require("safe-access");

var _safeAccess2 = _interopRequireDefault(_safeAccess);

var _validateSequenceArray = require("./utils/validateSequenceArray");

var _validateSequenceArray2 = _interopRequireDefault(_validateSequenceArray);

var _searchWholeObjByName = require("./utils/searchWholeObjByName");

var _searchWholeObjByName2 = _interopRequireDefault(_searchWholeObjByName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint-disable no-var*/


function parseSbolJson(sbolJson, options) {
  var name = void 0;
  if ((0, _safeAccess2.default)(sbolJson, "name[0]")) {
    name = (0, _safeAccess2.default)(sbolJson, "name[0]");
  } else {
    name = (0, _safeAccess2.default)(sbolJson, "displayId[0]");
  }
  return {
    // circular: access(sbolJson, "seq:circular[0]"), //tnrtodo this needs to be changed
    circular: false,
    sequence: (0, _safeAccess2.default)(sbolJson, "dnaSequence[0].DnaSequence[0].nucleotides"),
    name: name,
    features: (0, _flatmap2.default)(sbolJson.annotation, function (annotation) {
      var feature = (0, _safeAccess2.default)(annotation, "SequenceAnnotation[0]");
      if (feature) {
        var notes = (0, _searchWholeObjByName2.default)("ns2:about", feature);
        var otherNotes = (0, _searchWholeObjByName2.default)("ns2:resource", feature);
        notes.push.apply(notes, otherNotes);
        var newNotes = {};
        notes.forEach(function (note) {
          if (newNotes[note.prop]) {
            newNotes[note.prop].push(note.value);
          } else {
            newNotes[note.prop] = [note.value];
          }
        });
        var featureName = void 0;
        var nameMatches = (0, _searchWholeObjByName2.default)("name", feature);
        if (nameMatches[0] && nameMatches[0].value && nameMatches[0].value[0]) {
          featureName = nameMatches[0].value[0];
        } else {
          var displayMatches = (0, _searchWholeObjByName2.default)("displayId", feature);
          if (displayMatches[0] && displayMatches[0].value && displayMatches[0].value[0]) {
            featureName = displayMatches[0].value[0];
          }
        }
        return {
          name: featureName,
          notes: newNotes,
          type: "misc_feature", // sbol represents the feature type in what we are parsing as notes as the URL is difficult to follow
          // type: feature['seq:label'], //tnrtodo: figure out if an annotation type is passed
          // id: feature['seq:label'],
          start: parseInt((0, _safeAccess2.default)(feature, "bioStart[0]") - (options.inclusive1BasedStart ? 0 : 1)),
          end: parseInt((0, _safeAccess2.default)(feature, "bioEnd[0]") - (options.inclusive1BasedEnd ? 0 : 1)),
          strand: (0, _safeAccess2.default)(feature, "strand[0]") //+ or -
          // notes: feature['seq:label'],
        };
      }
    })
  };
}

exports.default = sbolXmlToJson;
module.exports = exports["default"];