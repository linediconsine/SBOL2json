import _regeneratorRuntime from "babel-runtime/regenerator";

//Here's what should be in the callback:
// {
//   parsedSequence:
//   messages:
//   success:
// }
var sbolXmlToJson = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(string, options) {
    var onFileParsed, response, result, sbolJsonMatches, resultArray, i;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = options || {};

            onFileParsed = function onFileParsed(sequences) {
              //before we call the onFileParsed callback, we need to validate the sequence
              return validateSequenceArray(sequences, options);
            };

            response = {
              parsedSequence: null,
              messages: [],
              success: true
            };
            _context.prev = 3;
            _context.next = 6;
            return new Promise(function (resolve, reject) {
              return parseString(string, function (err, result) {
                if (err) reject(err);else resolve(result);
              });
            });

          case 6:
            result = _context.sent;
            sbolJsonMatches = searchWholeObjByName("DnaComponent", result);

            if (!sbolJsonMatches[0]) {
              _context.next = 14;
              break;
            }

            resultArray = [];

            for (i = 0; i < sbolJsonMatches[0].value.length; i++) {
              try {
                response = {
                  parsedSequence: null,
                  messages: [],
                  success: true
                };
                response.parsedSequence = parseSbolJson(sbolJsonMatches[0].value[i], options);
              } catch (e) {
                console.error("error:", e);
                console.error("error.stack: ", e.stack);
                resultArray.push({
                  success: false,
                  messages: "Error while parsing Sbol format"
                });
              }
              if (response.parsedSequence.features.length > 0) {
                response.messages.push("SBOL feature types are stored in feature notes");
              }
              resultArray.push(response);
            }
            return _context.abrupt("return", onFileParsed(resultArray));

          case 14:
            return _context.abrupt("return", onFileParsed({
              success: false,
              messages: "XML is not valid Jbei or Sbol format"
            }));

          case 15:
            _context.next = 20;
            break;

          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](3);
            return _context.abrupt("return", onFileParsed({
              success: false,
              messages: "Error parsing XML to JSON"
            }));

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[3, 17]]);
  }));

  return function sbolXmlToJson(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
// Converts SBOL formats.
//  * Specifications for SBOL can be found at http://www.sbolstandard.org/specification/core-data-model
//  *
//  * The hierarcy of the components in an SBOL object is:
//  *
//  *          The hierarchy is Collection -> DnaComponent -> DnaSequence
//  *
//  * Check for each level and parse downward from there.
// tnrtodo: this should be tested with a wider variety of sbol file types!


function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/* eslint-disable no-var*/
import { parseString } from "xml2js";

import flatmap from "flatmap";
import access from "safe-access";
import validateSequenceArray from "./utils/validateSequenceArray";
import searchWholeObjByName from "./utils/searchWholeObjByName";function parseSbolJson(sbolJson, options) {
  var name = void 0;
  if (access(sbolJson, "name[0]")) {
    name = access(sbolJson, "name[0]");
  } else {
    name = access(sbolJson, "displayId[0]");
  }
  return {
    // circular: access(sbolJson, "seq:circular[0]"), //tnrtodo this needs to be changed
    circular: false,
    sequence: access(sbolJson, "dnaSequence[0].DnaSequence[0].nucleotides"),
    name: name,
    features: flatmap(sbolJson.annotation, function (annotation) {
      var feature = access(annotation, "SequenceAnnotation[0]");
      if (feature) {
        var notes = searchWholeObjByName("ns2:about", feature);
        var otherNotes = searchWholeObjByName("ns2:resource", feature);
        notes.push.apply(notes, otherNotes);
        var newNotes = {};
        notes.forEach(function (note) {
          if (newNotes[note.prop]) {
            newNotes[note.prop].push(note.value);
          } else {
            newNotes[note.prop] = [note.value];
          }
        });
        var featureName = void 0;
        var nameMatches = searchWholeObjByName("name", feature);
        if (nameMatches[0] && nameMatches[0].value && nameMatches[0].value[0]) {
          featureName = nameMatches[0].value[0];
        } else {
          var displayMatches = searchWholeObjByName("displayId", feature);
          if (displayMatches[0] && displayMatches[0].value && displayMatches[0].value[0]) {
            featureName = displayMatches[0].value[0];
          }
        }
        return {
          name: featureName,
          notes: newNotes,
          type: "misc_feature", // sbol represents the feature type in what we are parsing as notes as the URL is difficult to follow
          // type: feature['seq:label'], //tnrtodo: figure out if an annotation type is passed
          // id: feature['seq:label'],
          start: parseInt(access(feature, "bioStart[0]") - (options.inclusive1BasedStart ? 0 : 1)),
          end: parseInt(access(feature, "bioEnd[0]") - (options.inclusive1BasedEnd ? 0 : 1)),
          strand: access(feature, "strand[0]") //+ or -
          // notes: feature['seq:label'],
        };
      }
    })
  };
}

export default sbolXmlToJson;